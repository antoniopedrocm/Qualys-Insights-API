diff a/public/app.js b/public/app.js	(rejected hunks)
@@ -262,147 +262,185 @@ function updateCharts(summary, trends) {
         backgroundColor: 'rgba(0, 240, 224, 0.1)',
         tension: 0.3,
         fill: true,
         pointRadius: 2,
         pointBackgroundColor: '#00f0e0',
       }]
     },
     options: {
       responsive: true,
       maintainAspectRatio: false,
       plugins: { legend: { display: false } },
       scales: { 
         y: { beginAtZero: true, grid: { color: '#1a223a' } },
         x: { grid: { display: false } }
       }
     }
   });
 }
 
 async function loadVulnerabilities() {
   try {
     showLoading(true);
     const data = await apiCall('/api/vulnerabilities');
     currentData.vulnerabilities = data.data || [];
     currentData.filteredVulnerabilities = data.data || [];
+    populateTagFilter(currentData.vulnerabilities);
     displayVulnerabilities(currentData.vulnerabilities);
     document.getElementById('vulnTotal').textContent = currentData.vulnerabilities.length;
     showLoading(false);
     showMessage('Vulnerabilidades carregadas!', 'success');
   } catch (error) {
     showLoading(false);
     showMessage('Erro ao carregar vulnerabilidades: ' + error.message, 'error');
   }
 }
 
 function displayVulnerabilities(vulns) {
   const severityLabel = { '5': 'Crítica', '4': 'Alta', '3': 'Média', '2': 'Baixa', '1': 'Info' };
   const severityClass = { '5': 'critical', '4': 'high', '3': 'medium', '2': 'low', '1': 'low' };
-  
+
   document.getElementById('vulnCount').textContent = vulns.length;
   document.getElementById('vulnTableBody').innerHTML = vulns.map(v => `
     <tr>
       <td>${v.hostIp || ''}</td>
       <td>${v.hostDns || ''}</td>
       <td>${v.os || ''}</td>
       <td>${v.qid || ''}</td>
       <td>${v.title || ''}</td>
       <td class="severity-${severityClass[v.severity]}">${severityLabel[v.severity] || v.severity}</td>
       <td>${v.status || ''}</td>
       <td>${v.port || ''}</td>
       <td>${v.protocol || ''}</td>
-      <td>${v.firstFound ? v.firstFound.split('T')[0] : ''}</td>
       <td>${v.solution || ''}</td>
       <td>${v.results || ''}</td>
+      <td>${v.firstFound ? v.firstFound.split('T')[0] : ''}</td>
     </tr>
   `).join('');
 }
 
+function populateTagFilter(vulns) {
+  const tagSelect = document.getElementById('filterTagSelect');
+  if (!tagSelect) return;
+
+  const tagSet = new Set();
+  vulns.forEach(v => {
+    if (!v.hostTags) return;
+    v.hostTags
+      .split(/[;,|]/)
+      .map(tag => tag.trim())
+      .filter(Boolean)
+      .forEach(tag => tagSet.add(tag));
+  });
+
+  const sortedTags = Array.from(tagSet).sort((a, b) => a.localeCompare(b, 'pt-BR'));
+  tagSelect.innerHTML = '<option value="">Todas as tags</option>';
+
+  sortedTags.forEach(tag => {
+    const option = document.createElement('option');
+    option.value = tag;
+    option.textContent = tag;
+    tagSelect.appendChild(option);
+  });
+}
+
 function applyFilters() {
   const selectedSeverities = Array.from(document.querySelectorAll('.severity-filter:checked'))
     .map(cb => cb.value);
-  
-  const ip = document.getElementById('filterIp').value.toLowerCase().trim();
-  const dns = document.getElementById('filterDns').value.toLowerCase().trim();
-  const qid = document.getElementById('filterQid').value.trim();
-  const tags = document.getElementById('filterTags').value.toLowerCase().trim();
+
+  const searchTerm = document.getElementById('filterSearch').value.toLowerCase().trim();
+  const selectedTag = document.getElementById('filterTagSelect').value.toLowerCase();
   const cve = document.getElementById('filterCve').value.toUpperCase().trim();
   const status = document.getElementById('filterStatus').value;
 
   let filtered = currentData.vulnerabilities;
 
-  const hasActiveFilters = selectedSeverities.length < 5 || ip || dns || qid || tags || cve || status;
+  const hasActiveFilters = selectedSeverities.length < 5 || searchTerm || selectedTag || cve || status;
 
   if (!hasActiveFilters) {
     currentData.filteredVulnerabilities = filtered;
     displayVulnerabilities(filtered);
     return;
   }
 
   // Filtro de severidade
   if (selectedSeverities.length > 0 && selectedSeverities.length < 5) {
     filtered = filtered.filter(v => selectedSeverities.includes(v.severity));
   }
-  // Filtro de IP
-  if (ip) {
-    filtered = filtered.filter(v => v.hostIp && v.hostIp.toLowerCase().includes(ip));
-  }
-  // Filtro de DNS
-  if (dns) {
-    filtered = filtered.filter(v => v.hostDns && v.hostDns.toLowerCase().includes(dns));
-  }
-  // Filtro de QID
-  if (qid) {
-    filtered = filtered.filter(v => v.qid === qid);
+  // Busca rápida em múltiplos campos
+  if (searchTerm) {
+    filtered = filtered.filter(v => {
+      const valuesToSearch = [
+        v.hostIp,
+        v.hostDns,
+        v.title,
+        v.qid,
+        v.solution,
+        v.os,
+        v.hostTags,
+        v.results,
+        v.port,
+        v.protocol
+      ];
+
+      return valuesToSearch.some(value =>
+        value && value.toString().toLowerCase().includes(searchTerm)
+      );
+    });
   }
-  // Filtro de Tags
-  if (tags) {
-    filtered = filtered.filter(v => v.hostTags && v.hostTags.toLowerCase().includes(tags));
+  // Filtro de Tags selecionadas
+  if (selectedTag) {
+    filtered = filtered.filter(v => {
+      if (!v.hostTags) return false;
+      const tags = v.hostTags
+        .split(/[;,|]/)
+        .map(tag => tag.trim().toLowerCase())
+        .filter(Boolean);
+      return tags.includes(selectedTag);
+    });
   }
   // Filtro de CVE
   if (cve) {
     filtered = filtered.filter(v => v.results && v.results.toUpperCase().includes(cve));
   }
   // Filtro de Status
   if (status) {
     filtered = filtered.filter(v => v.status === status);
   }
 
   currentData.filteredVulnerabilities = filtered;
   displayVulnerabilities(filtered);
   
   if (filtered.length === 0) {
     showMessage('Nenhuma vulnerabilidade encontrada com os filtros aplicados.', 'error');
   }
 }
 
 function clearFilters() {
   document.querySelectorAll('.severity-filter').forEach(cb => cb.checked = true);
-  document.getElementById('filterIp').value = '';
-  document.getElementById('filterDns').value = '';
-  document.getElementById('filterQid').value = '';
-  document.getElementById('filterTags').value = '';
+  document.getElementById('filterSearch').value = '';
+  document.getElementById('filterTagSelect').value = '';
   document.getElementById('filterCve').value = '';
   document.getElementById('filterStatus').value = '';
 
   currentData.filteredVulnerabilities = currentData.vulnerabilities;
   displayVulnerabilities(currentData.vulnerabilities);
   
   showMessage('Filtros limpos!', 'success');
 }
 
 async function exportFiltered() {
   try {
     if (!currentData.filteredVulnerabilities || currentData.filteredVulnerabilities.length === 0) {
       showMessage('Nenhuma vulnerabilidade para exportar!', 'error');
       return;
     }
     const headers = ['IP do Host', 'DNS do Host', 'Tags', 'QID', 'Severidade', 'Tipo', 'Status', 'Porta', 'Protocolo', 'Primeira Detecção', 'Última Detecção'];
     const severityLabel = { '5': 'Crítica', '4': 'Alta', '3': 'Média', '2': 'Baixa', '1': 'Info' };
     
     let csv = headers.join(',') + '\n';
     
     currentData.filteredVulnerabilities.forEach(vuln => {
       const row = [
         vuln.hostIp,
         vuln.hostDns,
         vuln.hostTags || '',
